# <웹 애플리케이션 이해>
# [WEB 서버, WAB(Web Application Server)]
## 웹 서버(Web Server)
* HTTP 기반으로 동작
* 정적 리소스 제공, 기타 부가기능
* 정적(파일) HTML, CSS, JS, 이미지, 영상들을 제공해줌
* 예) NGINX, APACHE

## 웹 애플리케이션 서버(WAS - Web Application Server)
* HTTP 기반으로 동작
* 웹 서버 기능 포함 + (정적 리소스 제공 가능)
* 프로그램 코드를 실행해서 애플리케이션 로직 수행
  * 동적 HTML, HTTP API(JSON)
  * 서블릿, JSP, 스프링 MVC
* 예) 톰캣(Tomcat), Jetty, Undertow

## 웹 서버, 웹 애플리케이션 서버(WAS)의 차이
* 웹 서버는 정적 리소스(파일) 제공, WAS는 애플리케이션 로직까지 실행하여 제공
* 사실은 둘의 용어 및 경계가 모호하다.
  * 웹 서버도 프로그램을 실행하는 기능을 포함하기도 함(플러그인 설치)
  * 웹 애플리케이션 서버도 웹 서버의 기능을 제공한다.
* 자바는 서블릿 컨테이너 기능을 제공하면 WAS
  * 서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있다.
* WAS는 애플리케이션 코드를 실행하는데 더 특화되어 있다.

## 웹 시스템 구성 - WAS, DB (가장 간단한 조함)
* WAS, DB만으로 시스템 구성 가능
* WAS는 정적 리소스, 애플리케이션 로직 모두 제공 가능

한 개의 WAS만 사용하는 경우
* WAS가 너무 많은 역할을 담당, 서버 과부하 우려
* 가장 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어려울 수 있다.
* WAS 장애시 오류 화면도 노출 불가능 (WAS자체가 장애가나면 오류도 확인할 수 없음)   
  (애플리케이션 로직은 DB, 및 다른 서버 호출을 위한 비즈니스 로직이 있기때문에 비싸다고 표현)

## 웹 시스템 구성(일반적) - WEB, WAS, DB
* 정적 리소스는 웹 서버가 처리
* 웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임
* WAS는 중요한 애플리케이션 로직 처리 전담   
* 또한 효율적인 리소스 관리에 좋다
  * 정적 리소스가 많이 사용되면 Web 서버 증설
  * 애플리케이션 리소스가 많이 사용되면 WAS 증설
* 웹 서버는 잘 죽지 않음(단순한 정적파일 제공이므로)
* WAS, DB 장애시 WEB서버가 오류 화면 제공 가능
* 단순히 API만 주고받는 경우 웹 서버 없어도 됨(화면에 표시할것이 없으므로)

<br>

# [서블릿]
* 서블릿은 특정 HTTP 메소드로 서버가 요청을 받게되면 일어나는 동작들(**동작은 PPT 확인**) 중에서   
  비즈니스 로직 실행(데이터베이스에 저장 요청)을 제외한 나머지 부분들을 전부 커버해준다.(서버를 지원하는 WAS들이)
## 서블릿의 특징
```java
@Webservlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
  @Override
  protected void service(HttpServletRequest request, HttpServletResponse response) {
    //애플리케이션 로직
  }
}
```
* urlPatterns(/hello)의 URL이 호출되면 서블릿 코드가 실행된다.
* HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest
* HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse
* 개발자는 HTTP 스펙을 매우 편리하게 사용할 수 있지만, HTTP 스펙을 기본적으로 알아야 사용할때 편리하다.

##  HTTP 요청, 응답 흐름
* HTTP 요청 시
  * WAS : Request, Response 객체 새로 만든 후 서블릿 객체 호출(누가 호출하는지 모르므로 항상 새로 생성)
  * 개발자는 Request 객체에서 HTTP 요청 정보를 꺼내어 사용, Response 객체에는 HTTP 응답정보를 입력한다.
  * WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성한다.

## 서블릿 컨테이너 (톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라 한다.)
* 개발자는 서블릿 객체를 직접 생성하는것이 아닌 코드만 만듦
* WAS안에 서블릿 컨테이너에서 서블릿 객체를 자동으로 생성, 초기화, 호출, 종료하는 생명주기를 관리 해준다.
* 서블릿 객체는 **싱글톤으로 관리됨**
  * 고객의 요청이 올 때 마다 객체 생성 == 비효율
  * 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용
  * 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근
  * **공유 변수 사용 주의(Stateless 해야 함)**
  * 서블릿 컨테이너 종료시 함께 종료됨
* **동시 요청을 위한 멀티 스레드 처리 지원** : 중요한 특징(개발자는 크게 신경쓰지 않아도 됨)

<br>

# [동시 요청 - 멀티 쓰레드]
트래픽이 많아질 경우 사용할 수 있는 기법
* 클라이언트에서 서버로 요청을 하게 되면 TCP/IP커넥션이 연결되고 Servlet을 호출한다.
* 그렇다면 Servlet은 누가 호출할까? **쓰레드**

## 쓰레드
* 애플리케이션 코드를 각각 순차적으로 실행함
* 자바 메인 메서드를 처음 실행하면 main이라는 이름의 쓰레드가 실행된다.
* 쓰레드가 없으면 자바 애플리케이션의 실행이 불가능하다.
* 쓰레드는 한번에 하나의 코드 라인만 수행함
* 동시 처리가 필요하면 쓰레드를 추가로 생성해줘야한다.

단일 요청 - 쓰레드 하나 사용
* 요청이 하나 오면 WAS에서 쓰레드를 하나 할당하고 이를 이용해 Servlet 코드 실행

다중 요청 - 쓰레드 하나 사용
* 요청1, 요청2가 들어올때 요청1에서 쓰레드의 Servlet처리가 지연될때 요청 2가 들어오면?
* 쓰레드를 사용할 수 있을때까지 기다림
* 결국 둘다 죽어버리는 상황이 발생함
* 이것을 해결하기 위해서 신규 쓰레드를 생성한다.
* 즉 **요청이 올 때 마다 쓰레드를 생성한다.**

## 요청이 올 때 마다 쓰레드 생성의 장단점
**장점**
* 동시 요청 처리 가능
* 리소스(CPU, 메모리)가 허용할 때 까지 처리 가능
* 하나의 쓰레드가 지연돼도, 나머지 쓰레드 정상 동작

**단점**
 * 생성 비용이 매우 비쌈
   * 요청 올 때마다 생성 -> 응답 속도 늦어짐
 * 컨텍스트 스위칭 비용이 발생 (쓰레드1에서 쓰레드2로 전환할때 발생하는 비용)   
   쓰레드는 실제적으로는 동시가 아닌 순차적으로 처리하지만 매우 빠른 CPU의 속도로 동시처리처럼 보임
* 쓰레드 생성에 제한이 없다.
  * CPU, 메모리가 임계점을 넘어서 서버가 다운되는 상황 발생함

## 쓰레드 풀(Thread Pool)
하나의 풀장을 생각(특정 양의 쓰레드를 pool안에 만들어 놓음)
* 요청이 오면 쓰레드 풀에서 쓰레드를 요청한다.
* 요청이 종료되면 쓰레드는 쓰레드 풀로 다시 반납함
* 즉 미리 만들어서 넣어놓고 빌려쓰고 가져다 놓는 방식
* 서버가 200개의 요청이 한계라면 200개를 넘어서는 요청들은 대기하거나, 거절할 수 있다.

## 쓰레드 풀 - 요청 마다 쓰레드 생성의 단점 보안
특징
* 필요한 쓰레드를 쓰레드 풀에 보관하고 관리
* 쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리한다. 톰캣은 최대 200개 기본 설정(변경 가능)

사용
* 쓰레드가 필요시, 이미 생성된 쓰레드를 쓰레드 풀에서 꺼내 사용
* 사용 종료하면 쓰레드 풀에 해당 쓰레드를 반납
* 최대 쓰레드가 모두 사용중이어서 쓰레드 풀에 쓰레드가 없으면?
  * 기다리는 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정

장점
* 쓰레드가 미리 생성되어 있음, 쓰레드를 생성하고 종료하는 비용이 절약되고, 응답 시간 빠르다.
* 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.

## 쓰레드 풀 - 성능 튜닝 팁(실무)
* WAS의 주요 튜닝 포인트는 최대 쓰레드(max thread)의 수이다.
* 너무 낮게 설정
  * 동시 요청 많으면, 서버 리소스 여유롭지만, 클라이언트는 응답 지연
* 너무 높게 설정
  * 동시 요청 많으면, CPU, 메모리 리소스 임계점 초과로 서버 다운
* 장애 발생시?
  * 클라우드면 일단 서버부터 늘리고, 이후에 튜닝
  * 클라우드가 아니면 열심히 튜닝
  
## 쓰레드 풀의 적정 숫자는?
* 애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 다름
* 성능 테스트
  * 최대한 실제 서비스와 유사하게 성능 테스트 시도
  * 툴: 아파치 ab. 제이미터, nGrinder
  
## 핵심 - WAS의 멀티 쓰레드 지원
* 개발자는 멀티 쓰레드 관련 코드를 신경쓰지 않아도 된다.
* 개발자는 마치 싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발
* 멀티 쓰레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용(Stateless하게 사용)

<br>

# [HTML, HTTP API, CSR, SSR]
## HTML(정적, 동적), HTTP API
정적리소스 요청
* 고정된 파일은 그냥 **웹 서버**에서 이미 생성된 파일들을 보내준다.

HTML페이지(동적) 요청
* **WAS**에서 DB까지 조회해 동적으로 생성한 파일을 보내준다.

HTTP API
* HTML이 아닌 데이터를 전달한다. (주로 JSON)
* 다양한 곳에서 사용된다.
* **WAS**에서 DB를 조회해 JSON형식의 데이터를 전달한다.(페이지X)

HTTP API 사용   
HTTP API는 데이터만 주고 받으므로, 클라이언트가 별도로 처리한다.   
주로 앱 to 서버, 웹 클라이언트 to 서버, 서버 to 서버에서 사용된다.
* **웹 클라이언트**: 추가적으로 자바스크립트를 이용해(AJAX등) 필요한 페이지를 동적으로 만들어 뿌림

HTTP API는 다양한 시스템과 연동된다.
* 크게 두 가지의 접점으로 나뉜다.
    1. UI 클라이언트 접점: 앱, 웹 브라우저(자바스크립트통한 HTTP API 호출), React, Vue.js같은 웹 클라이언트
    2. 서버 to 서버: MAS(주문 서버 -> 결제 서버), 기업간 데이터 통신

> **백엔드 개발자는 크게 위의 3가지 방식을 고민해야 한다.**

## SSR, CSR
### Server Side Rendering
* 서버에서 최종 HTML을 생성해서 클라이언트에 전달      
  주로 정적인 화면에 이용
* 관련기술: JSP, 타입리프 -> **백엔드 개발자가 만듦**
### Client Side Rendering
* HTML결과를 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성해 적용
* 주로 동적인 화면에서 이용한다. (웹 환경을 앱과같이 필요부분만 수정할 수 있음)   
  (구글지도, Gmail, 캘린더 등)
* 관련기술: React, Vue.js -> **웹 프론트엔드 개발자가 만듦**

> React, Vue.js를 CSR + SSR 동시에 지원하는 웹 프레임워크도 존재   
> SSR을 사용하더라도 자바스크립트를 사용해 화면 일부 동적으로 변경할 수 있음

### CSR 동작 과정
1. HTML을 클라이언트가 요청하면 서버는 HTML 내용은 없고 **자바스크립트 링크**만 반환함
2. 웹 브라우저는 다시 **자바스크립트를 서버**에 요청하고, 서버가 반환하는 자바스크립트 코드에 클라이언트 로직, HTML 렌더링 코드를 포함시켜 보내준다.
3. 웹 브라우저는 애플리케이션 로직을 가지고 있으므로, **HTTP API**를 서버에 요청한다. 서버는 해당 데이터를 클라이언트로 전송한다.(주로 JSON)
4. 웹 브라우저는 클라이언트 로직을 이용해 API를 조회했기 때문에 HTML 렌더링 코드에 섞어서 동적인 웹 페이지를 만든다.

### 어디까지 알아야 할까?
* **서버 사이드 렌더링(SSR) 기술만 필수로 잘 알아보자!** -> 주로 타임리프

<br>

# [자바 웹 기술 역사]
* 서블릿 -> JSP -> 서블릿 + JSP: MVC -> 이런 패턴을 가지고 프레임워크가 나타남(스트럿츠, 웹워크, 스프링 MVC)

* 이후 Annotation기반의 스프링 MVC가 등장함   
  거의 모든 사람들이 사용

* 스프링 부트의 등장   
  서버를 내장, 서버에 WAS 설치하고, War파일을 만들어 설치한 WAS에 배포하는 과정을 빌드 결과(Jar)에 WAS 서버를 포함해 -> **빌드 배포를 크게 단순화 시켜준다.**

* 현재의 최신 기술
  * Web Servlet - Spring MVC
  * Web Reactive - Spring WebFlux
  
* 스프링 웹 플럭스   
특징
  * 비동기 넌 블로킹 처리
  * 최소 쓰레드 최대 성능 (CPU코어와 쓰레드 개수를 맞춤 -> Context Switching 비용 효율 좋아짐)
  * 함수형 스타일 -> 동시처리 코드 효율화
  * 서블릿 기술 사용 X   
그러나
* 기술적 난이도 높고, RDB지원 적음, 아직 많이 활용하지 않음

## 자바 - 뷰 템플릿의 역사
HTML을 편리하게 생성하는 뷰 기능

* JSP
  * 속도 느림, 기능 부족
* 프리마커, 벨로시티
  * 속도 문제 해결, 다양한 기능
* 타임리프(Thymeleaf)
  * 내추럴 템플릿: HTML의 모양을 유지하면서 뷰 템플릿 적용 가능
  * 스프링 MVC와 기능 통합

<br><br>

# <서블릿>
# [프로젝트 생성]
* jar아닌 war로 그래야 JSP를 사용할 수 있다.